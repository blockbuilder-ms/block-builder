"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkblock_builder_editor"] = self["webpackChunkblock_builder_editor"] || []).push([["src_core_dom_js"],{

/***/ "./src/core/dom.js":
/*!*************************!*\
  !*** ./src/core/dom.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst uuidv4 = (__webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/index.js\").v4);\r\n\r\n/**\r\n * DOM Class\r\n *\r\n * Will handle dom activity on the iframe, using native javascript\r\n * for best performance.\r\n */\r\nclass Dom {\r\n  constructor() {\r\n    /**\r\n     * Holds our doms data in a structureable and workable format\r\n     *\r\n     * @var {array}\r\n     */\r\n    this.structuredData = {\r\n      header: [],\r\n      content: [],\r\n      footer: [],\r\n    };\r\n\r\n    this._registerDocumentReference();\r\n  }\r\n\r\n  load() {\r\n    const self = this;\r\n\r\n    if (\r\n      !structuredData.header &&\r\n      !structuredData.content &&\r\n      !structuredData.footer\r\n    ) {\r\n      console.log(\"No structured data\");\r\n      return;\r\n    }\r\n\r\n    let structuredLocalData = structuredData;\r\n\r\n    if (\r\n      postObject.post_content !== \"\" &&\r\n      structuredLocalData.content.length === 0\r\n    ) {\r\n      window.getAppLoader().state.error = true;\r\n      window.getAppLoader().state.error_message =\r\n        \"Post has data, but no structured content.</br>Either the page is malformed or the page has been build using another builder.</br><strong class='text-xs'>Note: Applying the fix will overwrite the current content of the page</strong>\";\r\n\r\n      return;\r\n    }\r\n\r\n    if (structuredLocalData.content.length > 0) {\r\n      window.getAppLoader().event.on(\"bb-builder-loaded-before\", function () {\r\n        self.structuredData = structuredLocalData;\r\n        self.sync();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers a reference to the iframe element\r\n   * Saving it locally to be used later on.\r\n   *\r\n   * @return {void}\r\n   */\r\n  async _registerDocumentReference() {\r\n    const self = this;\r\n    const frame = document.querySelector(\"#builder-frame\");\r\n\r\n    if (frame.contentWindow.document.body) {\r\n      self.head = frame.contentWindow.document.head;\r\n      self.document = frame.contentWindow.document.body;\r\n      self.root = frame.contentWindow.document;\r\n      return;\r\n    }\r\n\r\n    frame.addEventListener(\"load\", async function () {\r\n      self.head = frame.contentWindow.document.head;\r\n      self.document = frame.contentWindow.document.body;\r\n      self.root = frame.contentWindow.document;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetches an element on the dom based on a universal\r\n   * css selector using js native functionalities.\r\n   *\r\n   * @param {*} selector\r\n   * @return {DomObject}\r\n   */\r\n  async get(selector, builderDom) {\r\n    const self = this;\r\n    let node;\r\n    let scope;\r\n\r\n    if (builderDom) {\r\n      scope = self.root;\r\n    } else {\r\n      scope = document;\r\n    }\r\n\r\n    if (selector.indexOf(\"#\") !== -1 && selector.indexOf(\" \") === -1) {\r\n      // This is an ID\r\n      node = scope.getElementById(selector.replace(\"#\", \"\"));\r\n    } else if (selector.indexOf(\"#\") !== -1 && selector.indexOf(\" \") !== -1) {\r\n      node = scope.querySelector(selector);\r\n    } else {\r\n      node = scope.querySelectorAll(selector);\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  async insertBefore(block, id) {\r\n    const self = this;\r\n    let result;\r\n    let collectionsHeader = self.structuredData.header;\r\n    let collectionsContent = self.structuredData.content;\r\n    let collectionsFooter = self.structuredData.footer;\r\n\r\n    result = await self._insertBefore(block, id, collectionsHeader);\r\n    if (result) {\r\n      return result;\r\n    }\r\n\r\n    result = await self._insertBefore(block, id, collectionsContent);\r\n    if (result) {\r\n      return result;\r\n    }\r\n\r\n    result = await self._insertBefore(block, id, collectionsFooter);\r\n    if (result) {\r\n      return result;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  async find(id) {\r\n    const self = this;\r\n\r\n    if (id === \"*\") {\r\n      return {\r\n        header: self.structuredData.header,\r\n        content: self.structuredData.content,\r\n        footer: self.structuredData.footer,\r\n      };\r\n    }\r\n\r\n    let result = await self._find(id, \"header\");\r\n    if (result) {\r\n      return result;\r\n    }\r\n\r\n    result = await self._find(id, \"content\");\r\n    if (result) {\r\n      return result;\r\n    }\r\n\r\n    result = await self._find(id, \"footer\");\r\n    if (result) {\r\n      return result;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  async _find(id, entry) {\r\n    const self = this;\r\n    let collections = self.structuredData[entry];\r\n\r\n    return await self._walkAndLook(collections, id);\r\n  }\r\n\r\n  async delete(id, softDelete) {\r\n    const self = this;\r\n    console.log(softDelete);\r\n    let result = await self._delete(\r\n      self.structuredData[\"header\"],\r\n      id,\r\n      softDelete\r\n    );\r\n    if (result) {\r\n      self.structuredData[\"header\"] = self.structuredData[\"header\"].filter(\r\n        function (entry) {\r\n          console.log(entry);\r\n          return \"object\" === typeof entry;\r\n        }\r\n      );\r\n\r\n      if (!softDelete) {\r\n        self.sync(\"header\");\r\n      }\r\n      return result;\r\n    }\r\n\r\n    result = await self._delete(self.structuredData[\"content\"], id, softDelete);\r\n    if (result) {\r\n      self.structuredData[\"content\"] = self.structuredData[\"content\"].filter(\r\n        function (entry) {\r\n          return \"object\" === typeof entry;\r\n        }\r\n      );\r\n\r\n      if (!softDelete) {\r\n        self.sync(\"content\");\r\n      }\r\n      return result;\r\n    }\r\n\r\n    result = await self._delete(self.structuredData[\"footer\"], id, softDelete);\r\n    if (result) {\r\n      self.structuredData[\"footer\"] = self.structuredData[\"footer\"].filter(\r\n        function (entry) {\r\n          return \"object\" === typeof entry;\r\n        }\r\n      );\r\n      if (!softDelete) {\r\n        self.sync(\"footer\");\r\n      }\r\n      return result;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  async _delete(collections, id, softDelete) {\r\n    const self = this;\r\n    let success = false;\r\n\r\n    for (let i in collections) {\r\n      let collection = collections[i];\r\n\r\n      if (!collection) {\r\n        continue;\r\n      }\r\n\r\n      if (collection[\"data-id\"] && collection[\"data-id\"] === id) {\r\n        delete collections[i];\r\n\r\n        if (!softDelete) {\r\n          let obj = self.document.querySelector(\"[data-id='\" + id + \"']\");\r\n          obj.parentNode.removeChild(obj);\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      if (collection.content && collection.content.length !== 0) {\r\n        success = await self._delete(collection.content, id, softDelete);\r\n      }\r\n    }\r\n\r\n    return success;\r\n  }\r\n\r\n  async duplicate(id) {\r\n    const self = this;\r\n\r\n    let result = await self._duplicate(self.structuredData[\"header\"], id);\r\n    if (result) {\r\n      self.sync();\r\n      return result;\r\n    }\r\n\r\n    result = await self._duplicate(self.structuredData[\"content\"], id);\r\n\r\n    if (result) {\r\n      self.sync();\r\n      return result;\r\n    }\r\n\r\n    result = await self._duplicate(self.structuredData[\"footer\"], id);\r\n    if (result) {\r\n      self.sync();\r\n      return result;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  async _duplicate(collections, id) {\r\n    const self = this;\r\n    let success = false;\r\n\r\n    for (let i in collections) {\r\n      let collection = collections[i];\r\n\r\n      if (!collection) {\r\n        continue;\r\n      }\r\n\r\n      if (collection[\"data-id\"] && collection[\"data-id\"] === id) {\r\n        let clone = structuredClone(collections[i]);\r\n        clone = await self.regenerateIds([clone]);\r\n        collections.push(clone[0]);\r\n\r\n        return true;\r\n      }\r\n\r\n      if (collection.content && collection.content.length !== 0) {\r\n        success = await self._duplicate(collection.content, id);\r\n      }\r\n    }\r\n\r\n    return success;\r\n  }\r\n\r\n  async walkerFor(item) {\r\n    let $template = await window.getAppLoader().template.get(\"walker-step\");\r\n\r\n    if (!$template || !item[\"data-id\"]) {\r\n      return false;\r\n    }\r\n\r\n    let options = $template.getAttribute(\"x-options\");\r\n\r\n    if (options) {\r\n      options = JSON.parse(options);\r\n      options.attributes.id = item[\"data-id\"];\r\n    }\r\n\r\n    $template.setAttribute(\"x-options\", JSON.stringify(options));\r\n\r\n    $template.innerHTML = $template.innerHTML.replaceAll(\r\n      \"{id}\",\r\n      item[\"data-id\"].substring(0, 12) + \"...\"\r\n    );\r\n\r\n    $template.innerHTML = $template.innerHTML.replaceAll(\r\n      \"{id-full}\",\r\n      item[\"data-id\"] ? item[\"data-id\"] : \"N/A\"\r\n    );\r\n\r\n    let json = JSON.stringify(item);\r\n\r\n    $template.innerHTML = $template.innerHTML.replaceAll(\r\n      \"{block}\",\r\n      json.replaceAll('\"', '\\\\\"')\r\n    );\r\n\r\n    $template.innerHTML = $template.innerHTML.replaceAll(\r\n      \"{item}\",\r\n      item[\"data-id\"]\r\n    );\r\n\r\n    $template.innerHTML = $template.innerHTML.replaceAll(\"{tag}\", item.tag);\r\n\r\n    let conditionals = $template.querySelectorAll(\"[x-if]\");\r\n\r\n    for (let i in conditionals) {\r\n      let conditional = conditionals[i];\r\n\r\n      if (\"object\" !== typeof conditional) {\r\n        continue;\r\n      }\r\n\r\n      let conditionalEntry = conditional.getAttribute(\"x-if\");\r\n      if (!item[conditionalEntry]) {\r\n        conditional.parentNode.removeChild(conditional);\r\n      }\r\n    }\r\n\r\n    if (item.content && item.content.length !== 0) {\r\n      let content = $template.querySelector(\"[x-content]\");\r\n      let items = structuredClone(item.content);\r\n      items.reverse();\r\n\r\n      for (let i in items) {\r\n        if (!items[i] || \"string\" === typeof items[i]) continue;\r\n        let s = structuredClone(items[i]);\r\n        s.child = true;\r\n\r\n        let node = await this.walkerFor(s);\r\n\r\n        if (node === false) {\r\n          continue;\r\n        }\r\n\r\n        content.appendChild(node);\r\n      }\r\n    }\r\n\r\n    return $template;\r\n  }\r\n\r\n  async _walkAndLook(collections, id) {\r\n    const self = this;\r\n    let res = false;\r\n\r\n    for (let i in collections) {\r\n      let collection = collections[i];\r\n\r\n      if (!collection) {\r\n        continue;\r\n      }\r\n\r\n      if (collection[\"data-id\"] && collection[\"data-id\"] === id) {\r\n        return collection;\r\n      }\r\n\r\n      if (collection.content) {\r\n        let LR = await self._walkAndLook(collection.content, id);\r\n        if (LR) {\r\n          res = LR;\r\n        }\r\n      }\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  async _insertBefore(block, targetId, collections) {\r\n    const self = this;\r\n    let res = false;\r\n\r\n    for (let i in collections) {\r\n      let collection = collections[i];\r\n\r\n      if (!collection) {\r\n        continue;\r\n      }\r\n\r\n      if (collection[\"data-id\"] && collection[\"data-id\"] === block[\"data-id\"]) {\r\n        delete collections[i];\r\n        let obj = self.document.querySelector(\r\n          \"[data-id='\" + block[\"data-id\"] + \"']\"\r\n        );\r\n        obj.parentNode.removeChild(obj);\r\n      }\r\n\r\n      if (collection.content && collection.content.filter) {\r\n        collection.content = collection.content.filter((n) => n);\r\n        let LR = await self._insertBefore(block, targetId, collection.content);\r\n        if (LR) {\r\n          res = LR;\r\n        }\r\n      }\r\n\r\n      if (collection[\"data-id\"] && collection[\"data-id\"] === targetId) {\r\n        if (collection.tag === block.dependencies[0]) {\r\n          if (!collection.content || 0 === collection.content.length) {\r\n            collection.content = [block];\r\n          } else {\r\n            collection.content.push(block);\r\n          }\r\n        } else {\r\n          collections.splice(i, 0, block);\r\n        }\r\n        res = true;\r\n      }\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Appends a block node to the builder editor\r\n   *\r\n   * @param {object} node\r\n   * @param {object} nodeContainer\r\n   * @param {object} nodeOptions\r\n   * @param {bool} parent\r\n   * @return {void}\r\n   */\r\n  async append(node, nodeContainer, nodeOptions, root, parent = false) {\r\n    const document = this.document;\r\n    let data;\r\n    nodeOptions = structuredClone(nodeOptions);\r\n\r\n    let options = nodeContainer.hasAttribute(\"x-options\")\r\n      ? JSON.parse(nodeContainer.getAttribute(\"x-options\"))\r\n      : {};\r\n\r\n    let container;\r\n    let rootLoc;\r\n\r\n    if (options.location) {\r\n      this.location = options.location;\r\n      let idSelector = options.location.indexOf(\"#\") !== -1;\r\n      let selector = idSelector\r\n        ? options.location\r\n        : \"[data-id='\" + options.location + \"']\";\r\n\r\n      container = document.querySelector(selector);\r\n\r\n      if (!container) {\r\n        console.log(options.location + \" was not found\");\r\n        return;\r\n      }\r\n\r\n      nodeOptions[\"data-id\"] = window.getAppLoader().block.generateId();\r\n      if (nodeOptions && nodeOptions.dependencies) {\r\n        data = await this._resolveDependencies(node, nodeOptions);\r\n      }\r\n\r\n      if (idSelector) {\r\n        rootLoc = this.location.replace(\"#\", \"\").replace(\"-wrap\", \"\");\r\n      } else {\r\n        rootLoc = options.root;\r\n      }\r\n\r\n      await this.structuredData[rootLoc].push(data);\r\n\r\n      await this.sync();\r\n\r\n      return document.querySelector(\r\n        '[data-id=\"' + nodeOptions[\"data-id\"] + '\"]'\r\n      );\r\n    }\r\n\r\n    // We need to know where to append.\r\n    if (!parent) {\r\n      return this.append(\r\n        node,\r\n        nodeContainer.parentNode,\r\n        nodeOptions,\r\n        root,\r\n        true\r\n      );\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Appends a block node to the builder editor\r\n   *\r\n   * @param {object} node\r\n   * @param {object} nodeContainer\r\n   * @param {object} nodeOptions\r\n   * @param {bool} parent\r\n   * @return {void}\r\n   */\r\n  async appendTo(node, container, nodeOptions) {\r\n    const document = this.document;\r\n\r\n    try {\r\n      nodeOptions = structuredClone(nodeOptions);\r\n      nodeOptions[\"data-id\"] = window.getAppLoader().block.generateId();\r\n      let object = await this.find(container.getAttribute(\"data-id\"));\r\n      if (object.length === 0) {\r\n        console.error(\"Did not find the container\");\r\n        return false;\r\n      }\r\n\r\n      if (!object.content) {\r\n        object.content = [];\r\n      }\r\n\r\n      if (\r\n        nodeOptions &&\r\n        nodeOptions.dependencies &&\r\n        nodeOptions.dependencies.indexOf(object.tag) === -1\r\n      ) {\r\n        console.log(\"dep not right\");\r\n        return false;\r\n      }\r\n\r\n      object.content.push(nodeOptions);\r\n      await this.sync();\r\n\r\n      let obj = document.querySelector(\r\n        '[data-id=\"' + nodeOptions[\"data-id\"] + '\"]'\r\n      );\r\n\r\n      obj.setAttribute(\"x-action\", \"drag\");\r\n\r\n      obj.setAttribute(\r\n        \"x-option\",\r\n        JSON.stringify({\r\n          emit: \"bb-block-move-before\",\r\n          attributes: { id: nodeOptions[\"data-id\"] },\r\n        })\r\n      );\r\n\r\n      obj.setAttribute(\"draggable\", true);\r\n\r\n      return obj;\r\n    } catch (e) {\r\n      console.log(node);\r\n      console.log(container);\r\n      console.log(e);\r\n\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async regenerateIds(collections) {\r\n    const self = this;\r\n\r\n    for (let i in collections) {\r\n      let collection = collections[i];\r\n\r\n      if (!collection) {\r\n        continue;\r\n      }\r\n\r\n      collection[\"data-id\"] = self.generateId();\r\n\r\n      if (collection.content) {\r\n        collection.content = await self.regenerateIds(collection.content);\r\n      }\r\n    }\r\n\r\n    return collections;\r\n  }\r\n\r\n  performUpdate(block, name, value, extra) {\r\n    const self = this;\r\n    // At this point we must handle various types\r\n    if (name.indexOf(\"@\") !== -1) {\r\n      _handleSubTarget(block);\r\n\r\n      return;\r\n    }\r\n\r\n    if (name.indexOf(\".\") !== -1) {\r\n      _handleTargetWithSteps(block);\r\n\r\n      return;\r\n    }\r\n\r\n    _handleTarget();\r\n\r\n    function _handleTarget() {\r\n      block[name] = value;\r\n\r\n      if (extra) {\r\n        block[name] = [value, extra.value];\r\n      } else {\r\n        block[name] = value;\r\n      }\r\n\r\n      self.sync();\r\n    }\r\n\r\n    function _handleTargetWithSteps(block) {\r\n      let steps = name.split(\".\");\r\n      let target = block[steps[0]];\r\n      if (steps.length === 2) {\r\n        if (extra) {\r\n          target[steps[1]] = [value, extra.value];\r\n        } else {\r\n          target[steps[1]] = value;\r\n        }\r\n      } else {\r\n        let total = steps.length;\r\n        let size = steps.length;\r\n\r\n        while (size--) {\r\n          let step = total - size;\r\n          target = target[step];\r\n        }\r\n\r\n        if (extra) {\r\n          target = [value, extra.value];\r\n        } else {\r\n          target = value;\r\n        }\r\n      }\r\n\r\n      self.sync();\r\n    }\r\n\r\n    function _handleSubTarget(block) {\r\n      // block[name] = value;\r\n      // self.sync();\r\n\r\n      let steps = name.split(\"|\");\r\n      let entry = steps[0].replace(\"@\", \"\");\r\n      let attributes = [steps[1]];\r\n      if (steps[1].indexOf(\".\") !== -1) {\r\n        attributes = steps[1].split(\".\");\r\n      }\r\n\r\n      if (!attributes) {\r\n        return false;\r\n      }\r\n\r\n      let target = block[entry];\r\n\r\n      if (attributes.length === 1) {\r\n        if (extra) {\r\n          target[attributes[0]] = [value, extra.value];\r\n        } else {\r\n          target[attributes[0]] = value;\r\n        }\r\n      } else {\r\n        let total = attributes.length;\r\n        let size = attributes.length;\r\n\r\n        while (size--) {\r\n          let step = total - size;\r\n          target = attributes[step];\r\n        }\r\n\r\n        if (extra) {\r\n          target = [value, extra.value];\r\n        } else {\r\n          target = value;\r\n        }\r\n      }\r\n\r\n      self.sync();\r\n    }\r\n  }\r\n  /**\r\n   * Syncs the dom with the structured data\r\n   *\r\n   * @return {bool}\r\n   */\r\n  async sync(section) {\r\n    // 1. prepare data\r\n    const self = this;\r\n    let data = self.structuredData;\r\n    console.log(\"syncing\");\r\n    if (!section) {\r\n      // 2. loop through structured data header\r\n      // 2a. update header per data in the structured data header key \"header\"\r\n      await self._sync(data.header, \"header-wrap\");\r\n\r\n      // 3. loop through structured data content\r\n      // 3a. update content per data in the structured data content key \"content\"\r\n      await self._sync(data.content, \"content-wrap\");\r\n\r\n      // 4. loop through structured data footer\r\n      // 4a. update footer per data in the structured data footer key \"footer\"\r\n      await self._sync(data.footer, \"footer-wrap\");\r\n    }\r\n\r\n    if (section) {\r\n      await self._sync(data[section], section + \"-wrap\");\r\n    }\r\n\r\n    window.getAppLoader().event.emit(\"bb-builder-synced-before\");\r\n  }\r\n\r\n  /**\r\n   * Synchronizes a section of dom.\r\n   *\r\n   * @param {object} data\r\n   * @param {string} where\r\n   */\r\n  async _sync(data, where) {\r\n    const self = this;\r\n    const document = self.document;\r\n    let initial = false;\r\n    const container = document.querySelector(\"#\" + where.replace(\"#\", \"\"));\r\n    if (0 !== data.length && container.classList.contains(\"empty-view\")) {\r\n      container.innerHTML = \"\";\r\n      container.classList.remove(\"empty-view\");\r\n      initial = true;\r\n    }\r\n\r\n    if (0 === data.length && container.innerHTML === \"\") {\r\n      let template = await window.getAppLoader().template.get(\"no-content\");\r\n      if (template) {\r\n        template.innerHTML = template.innerHTML.replace(\r\n          \"{name}\",\r\n          where.replace(\"#\", \"\")\r\n        );\r\n        template.innerHTML = template.innerHTML.replace(\r\n          \"{type}\",\r\n          where.replace(\"#\", \"\").replace(\"-wrap\", \"\")\r\n        );\r\n\r\n        if (where.indexOf(\"content\") !== -1) {\r\n          template.innerHTML = template.innerHTML.replace(\r\n            \"{description}\",\r\n            \"add blocks or a template to the page to remove this section of text.\"\r\n          );\r\n        } else {\r\n          template.innerHTML = template.innerHTML.replace(\r\n            \"{description}\",\r\n            \"If left empty it will not be shown on frontend.\"\r\n          );\r\n        }\r\n\r\n        container.appendChild(template);\r\n      }\r\n    }\r\n\r\n    await this._syncWalker(data, container, initial);\r\n  }\r\n\r\n  async _syncWalker(entries, container, initial) {\r\n    const self = this;\r\n    for (let i in entries) {\r\n      let entry = entries[i];\r\n\r\n      if (!entry) {\r\n        continue;\r\n      }\r\n\r\n      let data;\r\n      let layout;\r\n      let defaultData;\r\n\r\n      if (entry.multiStyle) {\r\n        if (entry[\"x-layout\"] && entry.default[entry[\"x-layout\"]]) {\r\n          layout = entry[\"x-layout\"];\r\n          data = entry;\r\n          entry.layout = layout;\r\n          defaultData = data.default[layout];\r\n        } else {\r\n          console.error(\"Layout was not found. Using default\");\r\n          data = entry;\r\n          layout = \"default\";\r\n          entry.layout = layout;\r\n          defaultData = data.default.default;\r\n        }\r\n      } else {\r\n        data = entry;\r\n        defaultData = data.default;\r\n      }\r\n\r\n      let hasContent =\r\n        \"object\" === typeof data.content && data.content.length !== undefined;\r\n\r\n      /**\r\n       * Emits event before rendering block\r\n       */\r\n      window.getAppLoader().event.emit(\"bb-before-rendering-block\", {\r\n        block: data,\r\n      });\r\n\r\n      let dObject = self.document.querySelector(\r\n        \"[data-id='\" + data[\"data-id\"] + \"']\"\r\n      );\r\n\r\n      // Valid id and already existing dom component\r\n      if (data[\"data-id\"] && dObject) {\r\n        // Update\r\n        for (let i in data.attributes) {\r\n          let key = data.attributes[i];\r\n          let value = data[key];\r\n\r\n          if (key === \"x-layout\") {\r\n            let template = await window\r\n              .getAppLoader()\r\n              .template.get(data.tag + \"-\" + value);\r\n\r\n            if (!template || template.length === 0) {\r\n              console.error(\"Layout was not found\");\r\n              continue;\r\n            }\r\n\r\n            dObject = self.document.querySelector(\r\n              \"[data-id='\" + data[\"data-id\"] + \"']\"\r\n            );\r\n\r\n            let parent = dObject.parentNode;\r\n\r\n            if (!parent) {\r\n              console.log(\"Parent not found\", parent);\r\n            }\r\n\r\n            template.setAttribute(\"data-id\", data[\"data-id\"]);\r\n            dObject.parentNode.replaceChild(template, dObject);\r\n\r\n            dObject = self.document.querySelector(\r\n              \"[data-id='\" + data[\"data-id\"] + \"']\"\r\n            );\r\n\r\n            continue;\r\n          }\r\n\r\n          if (key === \"x-hydrate\") {\r\n            if (!value) {\r\n              continue;\r\n            }\r\n            console.log(\"hydrating\", data);\r\n            let hydrated = false;\r\n\r\n            const appLoader = window.getAppLoader();\r\n            appLoader.event.on(\"bb-builder-synced-before\", async function () {\r\n              if (hydrated) {\r\n                return;\r\n              }\r\n\r\n              hydrated = true;\r\n              let requestObject = await appLoader.request.make();\r\n              requestObject.setUrl(\"/wp-json/\" + value);\r\n\r\n              let response = await appLoader.request.get(requestObject);\r\n\r\n              // Request was not 200 succes\r\n              if (response.status !== 200) {\r\n                appLoader.notification.error(response.response, 2500);\r\n                return;\r\n              }\r\n\r\n              if (response.body_response) {\r\n                // Find x-keys of the current block\r\n                let keyObjs = dObject.querySelectorAll(\"[x-key]\");\r\n                let slotObjs = dObject.querySelectorAll(\"[x-slot]\");\r\n                let keyCount = keyObjs.length - 1;\r\n                let keyStack = keyObjs.length;\r\n                let slotCount = slotObjs.length - 1;\r\n                let slotStack = slotObjs.length;\r\n\r\n                while (keyStack--) {\r\n                  let obj = keyObjs[keyCount - keyStack];\r\n\r\n                  if (!obj || \"object\" !== typeof obj) {\r\n                    continue;\r\n                  }\r\n\r\n                  let key = obj.getAttribute(\"x-key\");\r\n\r\n                  if (key.indexOf(\".\") !== -1) {\r\n                    // With steps\r\n                    let steps = key.split(\".\");\r\n\r\n                    if (steps.length === 0) {\r\n                      continue;\r\n                    }\r\n\r\n                    let stepsCount = steps.length - 1;\r\n                    let stepsStack = steps.length;\r\n                    let reference = response.body_response;\r\n\r\n                    while (stepsStack--) {\r\n                      let step = steps[stepsCount - stepsStack];\r\n\r\n                      if (!step) {\r\n                        break;\r\n                      }\r\n\r\n                      if (!reference[step]) {\r\n                        break;\r\n                      }\r\n\r\n                      reference = reference[step];\r\n                    }\r\n\r\n                    if (\r\n                      \"string\" === typeof reference ||\r\n                      \"number\" === typeof reference\r\n                    ) {\r\n                      if (\r\n                        [\"INPUT\", \"SELECT\", \"TEXTAREA\"].indexOf(obj.tagName) !==\r\n                        -1\r\n                      ) {\r\n                        obj.value = reference;\r\n                      } else {\r\n                        obj.innerHTML = reference;\r\n                      }\r\n                    } else {\r\n                      console.log(reference);\r\n                      console.log(typeof reference);\r\n                    }\r\n                  } else {\r\n                    if (\r\n                      [\"INPUT\", \"SELECT\", \"TEXTAREA\"].indexOf(obj.tagName) !==\r\n                      -1\r\n                    ) {\r\n                      if (response.body_response[key]) {\r\n                        obj.value = response.body_response[key];\r\n                      }\r\n                    } else {\r\n                      console.log(key);\r\n                      console.log(response.body_response[key]);\r\n\r\n                      if (response.body_response[key]) {\r\n                        obj.innerHTML = response.body_response[key];\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n\r\n                while (slotStack--) {\r\n                  let obj = slotObjs[slotCount - slotStack];\r\n\r\n                  if (!obj || \"object\" !== typeof obj) {\r\n                    continue;\r\n                  }\r\n\r\n                  let slot = obj.getAttribute(\"x-slot\");\r\n\r\n                  // A slot should be a key, value setup.\r\n                  // i.e [\"src\", \"attachments.post_thumbnail\"]\r\n                  try {\r\n                    let slotData = JSON.parse(slot);\r\n\r\n                    if (!slotData || slotData.length === 0) {\r\n                      continue;\r\n                    }\r\n\r\n                    let prop = slotData[0];\r\n                    let key = slotData[1];\r\n                    let localTarget;\r\n\r\n                    if (prop.indexOf(\"@\") !== -1 && prop.indexOf(\"|\") !== -1) {\r\n                      let split = prop.replace(\"@\", \"\").split(\"|\");\r\n                      prop = split[1];\r\n\r\n                      if (split[0].indexOf(\".\") === -1) {\r\n                        localTarget = obj.querySelector(split[0]);\r\n                      }\r\n                    } else {\r\n                      localTarget = obj;\r\n                    }\r\n\r\n                    if (key.indexOf(\".\") !== -1) {\r\n                      // With steps\r\n                      let steps = key.split(\".\");\r\n\r\n                      if (steps.length === 0) {\r\n                        continue;\r\n                      }\r\n\r\n                      let stepsCount = steps.length - 1;\r\n                      let stepsStack = steps.length;\r\n                      let reference = response.body_response;\r\n\r\n                      while (stepsStack--) {\r\n                        let step = steps[stepsCount - stepsStack];\r\n\r\n                        if (!step) {\r\n                          break;\r\n                        }\r\n\r\n                        if (!reference[step]) {\r\n                          break;\r\n                        }\r\n\r\n                        reference = reference[step];\r\n                      }\r\n\r\n                      if (\r\n                        \"string\" === typeof reference ||\r\n                        \"number\" === typeof reference\r\n                      ) {\r\n                        localTarget.setAttribute(prop, reference);\r\n                      } else {\r\n                        console.log(reference);\r\n                        console.log(typeof reference);\r\n                      }\r\n                    } else {\r\n                      // Without steps\r\n                      if (response.body_response[key]) {\r\n                        localTarget.setAttribute(\r\n                          prop,\r\n                          response.body_response[key]\r\n                        );\r\n                      }\r\n                    }\r\n                    console.log(slotData);\r\n                  } catch (e) {\r\n                    // Parsing error\r\n                    console.error(\"Slot parsing error with object\", obj);\r\n                  }\r\n                }\r\n              }\r\n            });\r\n\r\n            await self._applyData(data.default[data.layout], dObject, data);\r\n\r\n            continue;\r\n          }\r\n\r\n          if (key === \"label\") {\r\n            if (dObject.hasAttribute(\"x-content\")) {\r\n              dObject.innerHTML = value;\r\n            } else {\r\n              let localObject = dObject.querySelector(\"[x-content]\");\r\n              if (!localObject) {\r\n                console.log(\"Did not find content for: \" + data.tag);\r\n                continue;\r\n              }\r\n              localObject.innerHTML = value;\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          if (key && value) {\r\n            if (\"object\" === typeof value) {\r\n              let string = \"\";\r\n              for (let j in value) {\r\n                let name = j;\r\n                let s = value[j];\r\n                string +=\r\n                  name + \":\" + (\"string\" === typeof s ? s : s.join(\"\")) + \";\";\r\n              }\r\n              dObject.setAttribute(key, string);\r\n            } else {\r\n              dObject.setAttribute(key, value);\r\n            }\r\n          }\r\n        }\r\n\r\n        for (let i in data.structure) {\r\n          let s = data.structure[i];\r\n          let values = data[s];\r\n          let childObject = dObject.querySelector(s);\r\n\r\n          for (let j in data[s]) {\r\n            let key = j;\r\n            let value = data[s][j];\r\n            if (key === \"label\") {\r\n              if (childObject.hasAttribute(\"x-content\")) {\r\n                childObject.innerHTML = value;\r\n              } else {\r\n                childObject = childObject.querySelector(\"[x-content]\");\r\n                if (!childObject) {\r\n                  console.log(\"Did not find content for: \" + data.tag);\r\n                  continue;\r\n                }\r\n                childObject.innerHTML = value;\r\n              }\r\n\r\n              continue;\r\n            }\r\n\r\n            if (key && value) {\r\n              if (\"object\" === typeof value) {\r\n                let string = \"\";\r\n                for (let j in value) {\r\n                  let name = j;\r\n                  let s = value[j];\r\n                  string +=\r\n                    name + \":\" + (\"string\" === typeof s ? s : s.join(\"\")) + \";\";\r\n                }\r\n                childObject.setAttribute(key, string);\r\n              } else {\r\n                childObject.setAttribute(key, value);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        if (\r\n          \"object\" === typeof data.content &&\r\n          data.content.length !== undefined\r\n        ) {\r\n          console.log(\"walks\", data.content);\r\n          await self._syncWalker(\r\n            data.content,\r\n            dObject,\r\n            data.content,\r\n            !hasContent\r\n          );\r\n        }\r\n      } else if (data[\"data-id\"]) {\r\n        // Create\r\n        let template;\r\n        if (data.multiStyle) {\r\n          template = await window\r\n            .getAppLoader()\r\n            .template.get(data.tag + \"-\" + layout);\r\n        } else {\r\n          template = await window.getAppLoader().template.get(data.tag);\r\n        }\r\n\r\n        template.setAttribute(\"data-id\", data[\"data-id\"]);\r\n\r\n        if (!data.constructed) {\r\n          self._applyData(defaultData, template, data);\r\n        }\r\n\r\n        template.classList.add(\r\n          \"scale-90\",\r\n          \"opacity-0\",\r\n          \"duration-200\",\r\n          \"ease-in-out\",\r\n          \"transition-all\"\r\n        );\r\n\r\n        template.addEventListener(\"mousedown\", async function (e) {\r\n          if (e.target !== template) {\r\n            return;\r\n          }\r\n\r\n          if (\r\n            e.target.hasAttribute(\"x-action\") &&\r\n            e.target.getAttribute(\"x-action\") === \"drop\"\r\n          ) {\r\n            return;\r\n          }\r\n\r\n          e.preventDefault();\r\n          let root = await _lookForBlockRoot(e.target);\r\n\r\n          if (root === false) {\r\n            return;\r\n          }\r\n\r\n          let clickTI = setTimeout(() => {\r\n            if (!window.getAppLoader().state.dragItem) {\r\n              if (root.getAttribute(\"data-id\") === data[\"data-id\"]) {\r\n                window.getAppLoader().event.emit(\"bb-block-edit-before\", {\r\n                  item: e.target,\r\n                  block: data,\r\n                });\r\n              }\r\n            }\r\n            clearTimeout(clickTI);\r\n          }, 50);\r\n        });\r\n        /**\r\n         * Fetches and ensures the data is root block data.\r\n         *\r\n         * @param {object} entry\r\n         * @returns {object}\r\n         */\r\n        async function _lookForBlockRoot(entry) {\r\n          if (\r\n            entry.hasAttribute(\"x-action\") &&\r\n            entry.getAttribute(\"x-action\") === \"drop\"\r\n          ) {\r\n            return false;\r\n          }\r\n\r\n          if (entry.hasAttribute(\"data-id\")) {\r\n            return entry;\r\n          }\r\n\r\n          return await _lookForBlockRoot(entry.parentNode);\r\n        }\r\n\r\n        if (\r\n          container.hasAttribute(\"x-inner-content\") ||\r\n          container.hasAttribute(\"x-wrap\")\r\n        ) {\r\n          await container.prepend(template);\r\n        } else {\r\n          container.querySelector(\"[x-inner-content]\").prepend(template);\r\n        }\r\n\r\n        data.constructed = true;\r\n\r\n        dObject = container.querySelector(\r\n          \"[data-id='\" + data[\"data-id\"] + \"']\"\r\n        );\r\n\r\n        // Update\r\n        for (let i in data.attributes) {\r\n          let key = data.attributes[i];\r\n          let value = data[key];\r\n          let lObject;\r\n\r\n          if (key === \"label\") {\r\n            if (dObject.hasAttribute(\"x-content\")) {\r\n              dObject.innerHTML = value;\r\n            } else {\r\n              lObject = dObject.querySelector(\"[x-content]\");\r\n              if (!lObject) {\r\n                console.log(\"Did not find content for: \" + data.tag);\r\n                continue;\r\n              }\r\n              lObject.innerHTML = value;\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          if (key && value) {\r\n            if (\"object\" === typeof value) {\r\n              let string = \"\";\r\n              for (let j in value) {\r\n                let name = j;\r\n                let s = value[j];\r\n                string +=\r\n                  name + \":\" + (\"string\" === typeof s ? s : s.join(\"\")) + \";\";\r\n              }\r\n              dObject.setAttribute(key, string);\r\n            } else {\r\n              dObject.setAttribute(key, value);\r\n            }\r\n          }\r\n        }\r\n\r\n        for (let i in data.structure) {\r\n          let s = data.structure[i];\r\n          let values = data[s];\r\n          let childObject = dObject.querySelector(s);\r\n\r\n          for (let j in data[s]) {\r\n            let key = j;\r\n            let value = data[s][j];\r\n\r\n            if (key === \"label\") {\r\n              if (childObject.hasAttribute(\"x-content\")) {\r\n                childObject.innerHTML = value;\r\n              } else {\r\n                childObject = childObject.querySelector(\"[x-content]\");\r\n                if (!childObject) {\r\n                  console.log(\"Did not find content for: \" + data.tag);\r\n                  continue;\r\n                }\r\n                childObject.innerHTML = value;\r\n              }\r\n\r\n              continue;\r\n            }\r\n\r\n            if (key && value) {\r\n              if (\"object\" === typeof value) {\r\n                let string = \"\";\r\n                for (let j in value) {\r\n                  let name = j;\r\n                  let s = value[j];\r\n                  string +=\r\n                    name + \":\" + (\"string\" === typeof s ? s : s.join(\"\")) + \";\";\r\n                }\r\n                childObject.setAttribute(key, string);\r\n              } else {\r\n                childObject.setAttribute(key, value);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        setTimeout(() => {\r\n          dObject.classList.remove(\"scale-90\", \"opacity-0\");\r\n\r\n          setTimeout(() => {\r\n            dObject.classList.remove(\r\n              \"duration-200\",\r\n              \"ease-in-out\",\r\n              \"transition-all\"\r\n            );\r\n          }, 200);\r\n        });\r\n      }\r\n\r\n      /**\r\n       * Emits event before rendering block\r\n       */\r\n      window.getAppLoader().event.emit(\"bb-block-rendering-after\", {\r\n        block: data,\r\n        blockObject: dObject,\r\n      });\r\n\r\n      // if have children\r\n      if (\r\n        data.content &&\r\n        \"string\" !== typeof data.content &&\r\n        data.content.length !== 0\r\n      ) {\r\n        await self._syncWalker(data.content, dObject, data, initial);\r\n      } else if (data.content && \"string\" === typeof data.content) {\r\n        dObject.innerHTML = data.content;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  async _applyData(entries, template, data) {\r\n    const self = this;\r\n\r\n    if (entries.content) {\r\n      console.log(data.tag);\r\n      let value = entries.content;\r\n      if (\"string\" === typeof value) {\r\n        data.content = value;\r\n      }\r\n\r\n      if (\"object\" === typeof value) {\r\n        value = Object.values(value).reverse();\r\n        data.content = [];\r\n        for (let l in value) {\r\n          let s = value[l];\r\n\r\n          let block = structuredClone(\r\n            await window.getAppLoader().block.structure(s.tag)\r\n          );\r\n\r\n          if (!block) {\r\n            console.log(\"Default content is corrupted for \" + data.tag);\r\n          }\r\n\r\n          for (let i in s) {\r\n            if (i !== \"tag\" && i !== \"content\") {\r\n              block.default[i] = s[i];\r\n            }\r\n          }\r\n\r\n          if (s.content) {\r\n            s.content = Object.values(s.content).reverse();\r\n            block.content = await self._buildContentRecursively(s.content);\r\n          }\r\n\r\n          block[\"data-id\"] = self.generateId();\r\n          data.content.push(block);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i in entries) {\r\n      let type;\r\n      let attribute;\r\n      let target;\r\n      let targetSelector;\r\n      let value = entries[i];\r\n\r\n      if (i === \"content\") {\r\n        continue;\r\n      }\r\n\r\n      if (i.indexOf(\"@\") !== -1 && i.indexOf(\"|\") !== -1) {\r\n        let targetSplit = i.split(\"|\");\r\n        targetSelector = targetSplit[0].replace(\"@\", \"\");\r\n        attribute = targetSplit[1];\r\n\r\n        if (targetSelector.indexOf(\".\") !== -1) {\r\n          // Steps found\r\n          targetSelector = targetSelector.split(\".\").join(\" \");\r\n        }\r\n        type = \"@at\";\r\n        target = template.querySelector(targetSelector);\r\n      } else {\r\n        type = i;\r\n        target = template;\r\n      }\r\n\r\n      switch (type) {\r\n        case \"label\":\r\n          if (target.hasAttribute(\"x-content\")) {\r\n            target.innerHTML = value;\r\n          } else {\r\n            target = target.querySelector(\"[x-content]\");\r\n            if (!target) {\r\n              console.log(\"Did not find content for: \" + data.tag);\r\n              continue;\r\n            }\r\n            target.innerHTML = value;\r\n          }\r\n\r\n          data.label = value;\r\n          break;\r\n        case \"x-key\":\r\n          target.setAttribute(\"x-key\", value);\r\n          break;\r\n\r\n        case \"x-slot\":\r\n          console.log(target);\r\n          target.setAttribute(\"x-slot\", JSON.stringify(value));\r\n          break;\r\n\r\n        case \"@at\":\r\n          if (data) {\r\n            if (target) {\r\n              if (\"object\" === typeof value) {\r\n                let string = \"\";\r\n                for (let i in value) {\r\n                  string +=\r\n                    i +\r\n                    \":\" +\r\n                    (\"string\" === typeof value[i]\r\n                      ? value[i]\r\n                      : value[i].join(\"\")) +\r\n                    \";\";\r\n                }\r\n                target.setAttribute(attribute, string);\r\n              } else {\r\n                target.setAttribute(attribute, value);\r\n              }\r\n            }\r\n\r\n            data[targetSelector.split(\" \").join(\".\")] = {};\r\n            data[targetSelector.split(\" \").join(\".\")][attribute] = value;\r\n          }\r\n          break;\r\n        default:\r\n          if (target) {\r\n            if (\"object\" === typeof value) {\r\n              let string = \"\";\r\n              for (let i in value) {\r\n                let finalValue;\r\n                if (\"string\" === typeof value[i]) {\r\n                  finalValue = value[i];\r\n                } else if (\r\n                  \"object\" === typeof value[i] &&\r\n                  \"function\" === typeof value[i].join\r\n                ) {\r\n                  finalValue = value[i].join(\"\");\r\n                } else {\r\n                  finalValue = value[i];\r\n                }\r\n\r\n                string += i + \":\" + finalValue + \";\";\r\n              }\r\n              target.setAttribute(type, string);\r\n            } else {\r\n              target.setAttribute(type, value);\r\n            }\r\n          }\r\n\r\n          data[type] = value;\r\n      }\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  async _buildContentRecursively(tree) {\r\n    let content = [];\r\n\r\n    for (let i in tree) {\r\n      let s = tree[i];\r\n\r\n      let block = structuredClone(\r\n        await window.getAppLoader().block.structure(s.tag)\r\n      );\r\n\r\n      if (!block) {\r\n        console.log(\"Default content is corrupted for \" + data.tag);\r\n      }\r\n\r\n      for (let i in s) {\r\n        if (i !== \"tag\" && i !== \"content\") {\r\n          block.default[i] = s[i];\r\n        }\r\n      }\r\n\r\n      if (s.content) {\r\n        s.content = Object.values(s.content).reverse();\r\n        block.content = await this._buildContentRecursively(s.content);\r\n      }\r\n\r\n      block[\"data-id\"] = this.generateId();\r\n\r\n      content.push(block);\r\n    }\r\n\r\n    content = content.reverse();\r\n\r\n    return content;\r\n  }\r\n\r\n  async applyContentControls(template, entry) {\r\n    const self = this;\r\n\r\n    let appendBlock = await window\r\n      .getAppLoader()\r\n      .template.get(\"builder-block-append\");\r\n\r\n    let prependBlock = await window\r\n      .getAppLoader()\r\n      .template.get(\"builder-block-prepend\");\r\n\r\n    if (!appendBlock || !prependBlock) {\r\n      console.log(\"Content controls are not there or corrupt.\");\r\n      return;\r\n    }\r\n\r\n    let tag = entry.tag.split(\":\")[1];\r\n\r\n    prependBlock.setAttribute(\r\n      \"x-options\",\r\n      JSON.stringify({\r\n        location: \"#\" + entry[\"data-id\"],\r\n        type: tag,\r\n      })\r\n    );\r\n\r\n    prependBlock.innerHTML = prependBlock.innerHTML.replaceAll(\"{name}\", tag);\r\n\r\n    appendBlock.setAttribute(\r\n      \"x-options\",\r\n      JSON.stringify({\r\n        location: \"#\" + entry[\"data-id\"],\r\n        type: tag,\r\n      })\r\n    );\r\n\r\n    appendBlock.innerHTML = appendBlock.innerHTML.replaceAll(\"{name}\", tag);\r\n\r\n    template.prepend(prependBlock);\r\n    template.append(appendBlock);\r\n\r\n    return template;\r\n  }\r\n\r\n  /**\r\n   * Resolves dependencies of a to be appended/prepended node\r\n   * object, ensuring that it's container is suitable for it's\r\n   * needs\r\n   *\r\n   * @param {object} nodeContainer\r\n   * @param {object} nodeOptions\r\n   *\r\n   * @returns {object}\r\n   */\r\n  async _resolveDependencies(node, nodeOptions) {\r\n    const self = this;\r\n    let dependencies = nodeOptions.dependencies;\r\n\r\n    if (dependencies.length === 0) {\r\n      return nodeOptions;\r\n    }\r\n\r\n    /**\r\n     * Emits event before resolving dependency\r\n     */\r\n    await window.getAppLoader().event.emit(\"bb-before-resolve-dependency\", {\r\n      dependencies: dependencies,\r\n    });\r\n\r\n    // Grab first dependency\r\n    let dependency = dependencies[0];\r\n\r\n    // Get Template\r\n    const template = await window.getAppLoader().template.get(dependency);\r\n\r\n    // Make block\r\n    let block = await window.getAppLoader().block.make(dependency, template);\r\n\r\n    let blockOptions = structuredClone(\r\n      bbBlocks.filter(function (item) {\r\n        return item.tag === dependency;\r\n      })\r\n    );\r\n\r\n    if (blockOptions[0]) {\r\n      blockOptions = blockOptions[0];\r\n    }\r\n\r\n    blockOptions.content = [nodeOptions];\r\n    blockOptions[\"data-id\"] = window.getAppLoader().block.generateId();\r\n\r\n    if (!dependency || dependency !== \"@root\") {\r\n      if (blockOptions.dependencies) {\r\n        nodeOptions = await this._resolveDependencies(block, blockOptions);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Emits event after resolving dependency\r\n     */\r\n    await window.getAppLoader().event.emit(\"bb-after-resolve-dependency\", {\r\n      dependencies: nodeOptions.dependencies,\r\n      block: block,\r\n      options: blockOptions,\r\n    });\r\n\r\n    return nodeOptions;\r\n  }\r\n\r\n  async loadGoogleFont(fontName) {\r\n    const self = this;\r\n\r\n    var link = document.createElement(\"link\");\r\n    link.rel = \"stylesheet\";\r\n    link.href =\r\n      \"https://fonts.googleapis.com/css2?family=\" + fontName + \"&display=swap\";\r\n\r\n    console.log(self.document);\r\n    self.head.appendChild(link);\r\n    return true;\r\n  }\r\n\r\n  save() {\r\n    if (!this.structuredData) {\r\n      // Nothing to save\r\n      return false;\r\n    }\r\n\r\n    // Found data in header, save it\r\n    window.getAppLoader().event.emit(\"bb-header-save-before\", {\r\n      data: this.structuredData.header,\r\n    });\r\n\r\n    // Found data in content, save it\r\n    window.getAppLoader().event.emit(\"bb-content-save-before\", {\r\n      data: this.structuredData.content,\r\n    });\r\n\r\n    // Found data in footer, save it\r\n    window.getAppLoader().event.emit(\"bb-footer-save-before\", {\r\n      data: this.structuredData.footer,\r\n    });\r\n\r\n    setTimeout(() => {\r\n      // Finnish off by saving our style object as well.\r\n      window.getAppLoader().event.emit(\"bb-style-save-before\", {\r\n        data: this.style,\r\n      });\r\n    }, 500);\r\n  }\r\n\r\n  async build(data) {\r\n    let html = await this._build(data);\r\n\r\n    return html;\r\n  }\r\n\r\n  async _build(data) {\r\n    const self = this;\r\n    let html = \"\";\r\n    if (!self.style) {\r\n      self.style = {};\r\n    }\r\n\r\n    for (let i in data) {\r\n      let entry = data[i];\r\n\r\n      if (!entry) {\r\n        continue;\r\n      }\r\n\r\n      /**\r\n       * Emits event before building block\r\n       */\r\n      window.getAppLoader().event.emit(\"bb-before-building-block\", {\r\n        block: entry,\r\n      });\r\n\r\n      let template = await window.getAppLoader().template.get(entry.tag);\r\n\r\n      if (!template) {\r\n        console.log(entry);\r\n        return false;\r\n      }\r\n      /**\r\n       * Clean out builder used stuff\r\n       */\r\n      template.removeAttribute(\"x-inner-content\");\r\n      template.removeAttribute(\"x-content\");\r\n\r\n      /**\r\n       * Bind data from its block store to its component\r\n       */\r\n      if (entry[\"data-id\"]) {\r\n        template.setAttribute(\"data-id\", entry[\"data-id\"]);\r\n      }\r\n\r\n      /**\r\n       * If entry has no content, but a label - this label will be used as\r\n       * its inner content.\r\n       */\r\n      if (entry.label && !entry.content) {\r\n        template.innerHTML = entry.label;\r\n      }\r\n\r\n      for (let j in entry.attributes) {\r\n        let attribute = entry.attributes[j];\r\n\r\n        if (!entry[attribute] || attribute === \"style\") {\r\n          continue;\r\n        }\r\n\r\n        template.setAttribute(attribute, entry[attribute]);\r\n      }\r\n\r\n      /**\r\n       * Build dynamic generated class list of component\r\n       */\r\n      if (entry.style) {\r\n        self.style = await self._buildStyle(entry.style, self.style, template);\r\n      }\r\n\r\n      /**\r\n       * Emits event before rendering block\r\n       */\r\n      window.getAppLoader().event.emit(\"bb-after-building-block\", {\r\n        block: entry,\r\n      });\r\n\r\n      // if have children\r\n      if (\r\n        entry.content &&\r\n        entry.content.length !== 0 &&\r\n        \"string\" !== typeof entry.content\r\n      ) {\r\n        template.innerHTML = await self._build(entry.content, entry);\r\n      } else if (entry.content && \"string\" === typeof entry.content) {\r\n        template.innerHTML = entry.content;\r\n      }\r\n\r\n      let container = document.createElement(\"div\");\r\n      container.prepend(template);\r\n\r\n      html += container.innerHTML;\r\n    }\r\n\r\n    return html;\r\n  }\r\n\r\n  async _buildStyle(local, stylesheet, obj) {\r\n    //\r\n    for (let i in local) {\r\n      if (\"string\" === typeof local[i]) {\r\n        let selector = i + \"-\" + local[i].replace(\"#\", \"\");\r\n\r\n        /**\r\n         * Cleanup of ilegal and unwanted string literals\r\n         */\r\n        selector = selector.replaceAll(\" \", \"-\");\r\n        selector = selector.replaceAll(\".\", \"-\");\r\n        selector = selector.replaceAll(\"'\", \"\");\r\n        selector = selector.replaceAll(\",\", \"\");\r\n        selector = selector.replaceAll(\";\", \"\");\r\n\r\n        /**\r\n         * Only lowercase\r\n         */\r\n        selector = selector.toLowerCase();\r\n\r\n        obj.classList.add(selector);\r\n\r\n        if (stylesheet[selector] !== undefined) {\r\n          // Style already exists\r\n          continue;\r\n        }\r\n\r\n        let lStyle = \".\" + selector + \"{\" + i + \":\" + local[i] + \"}\";\r\n        stylesheet[selector] = lStyle;\r\n      }\r\n\r\n      if (\"object\" === typeof local[i]) {\r\n        let selector = i + \"-\" + local[i].join(\"\").replace(\"#\", \"\");\r\n\r\n        /**\r\n         * Cleanup of ilegal and unwanted string literals\r\n         */\r\n        selector = selector.replaceAll(\" \", \"-\");\r\n        selector = selector.replaceAll(\".\", \"-\");\r\n        selector = selector.replaceAll(\"'\", \"\");\r\n        selector = selector.replaceAll(\",\", \"\");\r\n        selector = selector.replaceAll(\";\", \"\");\r\n\r\n        /**\r\n         * Only lowercase\r\n         */\r\n        selector = selector.toLowerCase();\r\n\r\n        obj.classList.add(selector);\r\n\r\n        if (stylesheet[selector] !== undefined) {\r\n          // Style already exists\r\n          continue;\r\n        }\r\n\r\n        let lStyle = \".\" + selector + \"{\" + i + \":\" + local[i].join(\"\") + \"}\";\r\n        stylesheet[selector] = lStyle;\r\n      }\r\n    }\r\n\r\n    return stylesheet;\r\n  }\r\n\r\n  savePageStyles() {}\r\n\r\n  _getStyle() {\r\n    return this.style;\r\n  }\r\n\r\n  generateId() {\r\n    return uuidv4();\r\n  }\r\n\r\n  reload() {\r\n    console.log(\"reloads\");\r\n    document.getElementById(\"builder-frame\").contentWindow.location.reload();\r\n  }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dom);\r\n\n\n//# sourceURL=webpack://block-builder-editor/./src/core/dom.js?");

/***/ })

}]);